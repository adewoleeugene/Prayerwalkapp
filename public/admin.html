<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Prayer Walk Admin Dashboard</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root {
      --bg: #edf1f7;
      --card: #ffffff;
      --border: #d6dfec;
      --text: #12284a;
      --muted: #5f7292;
      --primary: #1f66ff;
      --chip: #e5ebf4;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "Avenir Next", "Segoe UI", sans-serif;
      min-height: 100vh;
      padding: 16px;
    }

    .shell {
      display: grid;
      gap: 16px;
      grid-template-columns: 1.3fr 0.9fr;
      max-width: 1660px;
      margin: 0 auto;
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: 0 8px 22px rgba(24, 40, 72, 0.07);
    }

    .header {
      grid-column: 1 / span 2;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
      padding: 20px;
    }

    .title {
      margin: 0;
      font-size: 2rem;
      line-height: 1.1;
    }

    .subtitle {
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 1.05rem;
    }

    .stats {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(140px, 1fr));
      margin-left: auto;
      justify-items: stretch;
    }

    .header-controls {
      display: flex;
      gap: 8px;
      margin-left: 12px;
      align-items: center;
    }

    .header-btn {
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      border-radius: 999px;
      padding: 9px 14px;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      text-decoration: none;
    }

    .header-btn.danger {
      border-color: #f2bcbc;
      color: #ab2f2f;
      background: #fff5f5;
    }

    .stat {
      border: 1px solid var(--border);
      border-radius: 16px;
      background: #f4f7fc;
      padding: 12px;
    }

    .stat-label {
      color: var(--muted);
      font-size: 0.75rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .stat-value {
      margin-top: 6px;
      font-size: 2rem;
      font-weight: 700;
      line-height: 1;
    }

    .left {
      padding: 16px;
    }

    .chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .chip {
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      background: var(--chip);
      color: var(--text);
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
    }

    .chip.active {
      background: var(--primary);
      color: #fff;
    }

    .chip-select {
      border: 2px solid var(--border);
      border-radius: 999px;
      background: #fff;
      color: var(--muted);
      padding: 9px 12px;
      font-size: 1rem;
      font-weight: 700;
      min-width: 180px;
    }

    .chip-input {
      border: 2px solid var(--border);
      border-radius: 999px;
      background: #fff;
      color: var(--muted);
      padding: 8px 12px;
      font-size: 0.95rem;
      font-weight: 700;
      min-width: 180px;
      height: 42px;
    }

    #map {
      border: 1px solid var(--border);
      border-radius: 16px;
      min-height: 620px;
      width: 100%;
      background: #f8fbff;
    }

    .legend {
      margin-top: 10px;
      color: var(--muted);
      font-size: 0.92rem;
    }

    .pin-count-badge {
      background: #1f66ff;
      color: #fff;
      border: 1px solid #ffffff;
      border-radius: 999px;
      font-size: 0.74rem;
      font-weight: 700;
      line-height: 1;
      padding: 3px 6px;
      box-shadow: 0 2px 8px rgba(17, 36, 66, 0.2);
      white-space: nowrap;
    }

    .right {
      padding: 16px;
      display: flex;
      flex-direction: column;
      min-height: 620px;
      position: relative;
    }

    .right h2 {
      margin: 0;
      font-size: 2rem;
      line-height: 1.1;
    }

    .history-search {
      margin-top: 10px;
      margin-bottom: 8px;
      width: 100%;
      padding-right: 38px;
    }

    .history-search-wrap {
      position: relative;
    }

    .history-filter-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr auto;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }

    .history-search-icon {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--muted);
      pointer-events: none;
      font-size: 0.95rem;
    }

    .history-list {
      margin-top: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: auto;
      max-height: calc(100vh - 250px);
      padding-right: 4px;
    }

    .history-pager {
      margin-top: 10px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    .pager-btn {
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.82rem;
      font-weight: 700;
      cursor: pointer;
    }

    .pager-btn.active {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary);
    }

    .walk {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: #fff;
      padding: 12px;
      cursor: pointer;
      transition: transform .12s ease, box-shadow .12s ease;
    }

    .walk:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(20, 36, 62, 0.08);
    }

    .walk-top {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .focus {
      font-size: 1.08rem;
      margin: 8px 0;
      font-weight: 700;
      line-height: 1.2;
    }

    .meta {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 0.88rem;
    }

    .tag {
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 700;
      padding: 3px 8px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .tag.path {
      color: #b42323;
      background: #fee2e2;
    }

    .tag.area {
      color: #1459a8;
      background: #dbeeff;
    }

    .sheet {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: #f7faff;
      padding: 12px;
      display: none;
    }

    .sheet.show {
      display: block;
      margin-top: 8px;
      box-shadow: 0 10px 22px rgba(18, 40, 74, 0.12);
    }

    .sheet h3 {
      margin: 0 0 6px;
      font-size: 1.1rem;
    }

    .sheet p {
      margin: 5px 0;
      color: var(--muted);
    }

    .actions {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn {
      border: none;
      border-radius: 10px;
      padding: 9px 13px;
      font-weight: 700;
      cursor: pointer;
    }

    .btn.primary {
      color: #fff;
      background: var(--primary);
    }

    .btn.ghost {
      color: var(--text);
      background: #e7edf8;
    }

    .status {
      margin-top: 10px;
      color: var(--muted);
      font-size: 0.93rem;
    }

    .empty {
      margin-top: 10px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .superadmin-panel {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: #f7faff;
      padding: 12px;
      display: none;
    }

    .superadmin-panel.show {
      display: block;
    }

    .superadmin-panel h3 {
      margin: 0 0 8px;
      font-size: 1.06rem;
    }

    .superadmin-grid {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    .admin-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 270px;
      overflow: auto;
    }

    .admin-item {
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 10px;
      padding: 8px;
    }

    .admin-meta {
      font-size: 0.85rem;
      color: var(--muted);
      margin-top: 4px;
    }

    .admin-actions {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .mini-input {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      min-width: 140px;
      font-size: 0.84rem;
    }

    .mini-btn {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 5px 10px;
      background: #fff;
      color: var(--text);
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 700;
    }

    .mini-btn.warn {
      background: #ffe8e8;
      border-color: #ffb3b3;
      color: #9d2020;
    }

    @media (max-width: 1180px) {
      .shell {
        grid-template-columns: 1fr;
      }

      .header {
        grid-column: auto;
        flex-direction: column;
        align-items: flex-start;
      }

      .stats {
        width: 100%;
      }

      #map {
        min-height: 420px;
      }

      .history-list {
        max-height: 450px;
      }

      .history-filter-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <main class="shell">
    <header class="panel header">
      <div>
        <h1 class="title">Prayer Walk Admin Dashboard</h1>
        <p class="subtitle">Walks and people in one operational view.</p>
      </div>
      <div class="stats">
        <article class="stat">
          <div class="stat-label">Walks</div>
          <div id="statWalks" class="stat-value">0</div>
        </article>
        <article class="stat">
          <div class="stat-label">Distance</div>
          <div id="statDistance" class="stat-value">0 km</div>
        </article>
      </div>
      <div class="header-controls">
        <a class="header-btn" href="/admin-settings.html" id="settingsLink">Settings</a>
        <button class="header-btn danger" id="logoutBtn" type="button">Log Out</button>
      </div>
    </header>

    <section class="panel left">
      <div class="chips">
        <button class="chip" data-days="1">Today</button>
        <button class="chip active" data-days="7">7 days</button>
        <button class="chip" data-days="30">30 days</button>
      </div>
      <div id="map"></div>
      <p class="legend">Heavier walked paths show stronger opacity. Tap route/area for details.</p>
      <p id="statusText" class="status"></p>
    </section>

    <section class="panel right">
      <h2>Walk History</h2>
      <div class="history-search-wrap">
        <input id="searchQuery" class="chip-input history-search" type="search" aria-label="Search walks"
          placeholder="Search name, location, branch..." />
        <span class="history-search-icon" aria-hidden="true">&#128269;</span>
      </div>
      <div class="history-filter-grid" id="filterGrid">
        <select id="branchFilter" class="chip-select" aria-label="Branch filter">
          <option value="">Any branch</option>
        </select>
        <span id="branchLabel" class="chip-select"
          style="display:none;font-weight:700;color:var(--text);cursor:default;"></span>
        <input id="startDateTime" class="chip-input" type="datetime-local" aria-label="Start date and time" />
        <input id="endDateTime" class="chip-input" type="datetime-local" aria-label="End date and time" />
        <button id="clearFiltersBtn" class="chip">Clear</button>
      </div>
      <div id="historyList" class="history-list"></div>
      <div id="historyPager" class="history-pager"></div>
      <p id="emptyState" class="empty" style="display:none;">No prayer walks in this filter.</p>

      <article id="detailSheet" class="sheet">
        <h3 id="detailTitle">Walk details</h3>
        <p id="detailWho"></p>
        <p id="detailWhen"></p>
        <p id="detailDuration"></p>
        <p id="detailDistance"></p>
        <p id="detailSpeed"></p>
        <p id="detailStartCoord"></p>
        <p id="detailEndCoord"></p>
        <p id="detailBranch"></p>
        <div class="actions">
          <button id="actionPrimary" class="btn primary">Replay</button>
          <button id="actionSecondary" class="btn ghost">Close</button>
        </div>
      </article>

      <section id="superadminPanel" class="superadmin-panel">
        <h3>Superadmin Branch Admin Control</h3>
        <div class="superadmin-grid">
          <input id="inviteEmail" class="chip-input" type="email" placeholder="Pastor email"
            aria-label="Pastor email" />
          <input id="inviteBranch" class="chip-input" type="text" placeholder="Branch slug or name"
            aria-label="Branch" />
          <button id="sendInviteBtn" class="chip">Send Invite</button>
        </div>
        <div id="superadminStatus" class="status"></div>
        <div id="adminList" class="admin-list"></div>
      </section>
    </section>
  </main>

  <script>
    const map = L.map('map', { zoomControl: true, maxZoom: 19 }).setView([8.48847, -13.26486], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const layerGroup = L.layerGroup().addTo(map);

    const state = {
      days: 7,
      rawWalks: [],
      walks: [],
      filterQuery: '',
      filterBranch: '',
      filterStartAt: '',
      filterEndAt: '',
      page: 1,
      pageSize: 5,
      hasAutoFitted: false,
      suppressAutoFitOnce: false,
      closeFocusPoint: null,
      selected: null,
      replayTimer: null,
      replayMarker: null,
      layers: new Map()
    };

    const params = new URLSearchParams(window.location.search);
    const tokenFromQuery = params.get('token');
    if (tokenFromQuery) {
      localStorage.setItem('adminToken', tokenFromQuery);
      params.delete('token');
      const cleanUrl = `${window.location.pathname}${params.toString() ? `?${params.toString()}` : ''}`;
      window.history.replaceState({}, document.title, cleanUrl);
    }

    const authToken = localStorage.getItem('adminToken') || '';
    if (!authToken) {
      window.location.replace('/admin');
    }
    const existingRole = (localStorage.getItem('adminUserRole') || '').toLowerCase();
    if (existingRole === 'superadmin') {
      window.location.replace('/superadmin.html?v=superadmin-20260224');
    }

    const searchQuery = document.getElementById('searchQuery');
    const branchFilter = document.getElementById('branchFilter');
    const startDateTime = document.getElementById('startDateTime');
    const endDateTime = document.getElementById('endDateTime');
    const clearFiltersBtn = document.getElementById('clearFiltersBtn');
    const settingsLink = document.getElementById('settingsLink');
    const logoutBtn = document.getElementById('logoutBtn');
    const historyList = document.getElementById('historyList');
    const historyPager = document.getElementById('historyPager');
    const emptyState = document.getElementById('emptyState');
    const statusText = document.getElementById('statusText');
    const adminRole = (localStorage.getItem('adminUserRole') || '').toLowerCase();
    const isSuperadmin = adminRole === 'superadmin';
    let adminBranch = (localStorage.getItem('adminUserBranch') || '').trim();

    // For branch admins: always hide the dropdown regardless of cached branch
    if (!isSuperadmin) {
      branchFilter.style.display = 'none';
      document.getElementById('filterGrid').style.gridTemplateColumns = '1fr 1fr auto';
      const branchLabel = document.getElementById('branchLabel');
      branchLabel.style.display = '';

      if (adminBranch) {
        branchLabel.textContent = 'ðŸ“ ' + adminBranch.charAt(0).toUpperCase() + adminBranch.slice(1);
      } else {
        // Branch not cached yet â€” fetch from API and cache it
        branchLabel.textContent = 'ðŸ“ Loading...';
        fetch('/admin/me', { headers: { Authorization: `Bearer ${authToken}` } })
          .then((r) => { if (r.status === 401) { handleUnauthorized(); throw new Error('401'); } return r.json(); })
          .then((data) => {
            const branch = data?.profile?.branch || '';
            if (branch) {
              localStorage.setItem('adminUserBranch', branch);
              branchLabel.textContent = 'ðŸ“ ' + branch.charAt(0).toUpperCase() + branch.slice(1);
            } else {
              branchLabel.textContent = 'ðŸ“ My Branch';
            }
          })
          .catch(() => { branchLabel.textContent = 'ðŸ“ My Branch'; });
      }
    }
    const superadminPanel = document.getElementById('superadminPanel');
    const inviteEmail = document.getElementById('inviteEmail');
    const inviteBranch = document.getElementById('inviteBranch');
    const sendInviteBtn = document.getElementById('sendInviteBtn');
    const superadminStatus = document.getElementById('superadminStatus');
    const adminList = document.getElementById('adminList');
    let searchDebounceTimer = null;
    let superadminRefreshTimer = null;

    function setStatus(text) {
      statusText.textContent = text || '';
    }

    function setSuperadminStatus(text) {
      if (!superadminStatus) return;
      superadminStatus.textContent = text || '';
    }

    function handleUnauthorized() {
      ['adminToken', 'adminUserRole', 'adminUserEmail', 'adminUserBranch'].forEach((k) => localStorage.removeItem(k));
      window.location.replace('/admin-login.html');
    }

    function logout() {
      handleUnauthorized();
    }

    function toDurationLabel(seconds) {
      const safe = Math.max(0, Math.floor(Number(seconds || 0)));
      const h = Math.floor(safe / 3600);
      const m = Math.floor((safe % 3600) / 60);
      if (h > 0) return `${h}h ${m}m`;
      return `${m}m`;
    }

    function toDistanceLabel(meters) {
      const value = Number(meters || 0);
      if (value >= 1000) return `${(value / 1000).toFixed(2)} km`;
      return `${Math.round(value)} m`;
    }

    function toSpeedLabel(distanceMeters, durationSeconds) {
      const meters = Math.max(0, Number(distanceMeters || 0));
      const seconds = Math.max(0, Number(durationSeconds || 0));
      if (!meters || !seconds) return '0.00 km/h';
      const km = meters / 1000;
      const hours = seconds / 3600;
      if (!hours) return '0.00 km/h';
      return `${(km / hours).toFixed(2)} km/h`;
    }

    function toParticipantLabel(walk) {
      if (!walk || typeof walk !== 'object') return 'Unknown participants';

      if (Array.isArray(walk.participantNames) && walk.participantNames.length) {
        return walk.participantNames
          .map((name) => String(name || '').trim())
          .filter(Boolean)
          .join(', ');
      }

      if (Array.isArray(walk.participants) && walk.participants.length) {
        return walk.participants
          .map((name) => String(name || '').trim())
          .filter(Boolean)
          .join(', ');
      }

      if (typeof walk.participants === 'string') {
        try {
          const parsed = JSON.parse(walk.participants);
          if (Array.isArray(parsed) && parsed.length) {
            const names = parsed
              .map((name) => String(name || '').trim())
              .filter(Boolean);
            if (names.length) return names.join(', ');
          }
        } catch (_) { }
      }

      return 'Unknown participants';
    }

    function toCardParticipantLabel(walk) {
      const full = toParticipantLabel(walk);
      if (!full || full === 'Unknown participants') return 'Unknown participants';

      const names = full
        .split(',')
        .map((name) => name.trim())
        .filter(Boolean);

      if (names.length <= 2) return names.join(', ');
      return `${names.slice(0, 2).join(', ')} +${names.length - 2} more`;
    }

    function toPointLabel(point) {
      if (!point) return 'Unknown';
      const lat = Number(point.latitude);
      const lng = Number(point.longitude);
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) return 'Unknown';
      return `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
    }

    function getWalkStartEndPoints(walk) {
      const points = Array.isArray(walk?.points) ? walk.points : [];
      if (!points.length) return { start: null, end: null };
      return {
        start: points[0] || null,
        end: points[points.length - 1] || points[0] || null
      };
    }

    function toLatLngPoint(point) {
      if (!point) return null;
      const lat = Number(point.latitude);
      const lng = Number(point.longitude);
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
      return { latitude: lat, longitude: lng };
    }

    function distanceMetersBetweenPoints(a, b) {
      if (!a || !b) return Number.POSITIVE_INFINITY;
      const toRad = (deg) => (deg * Math.PI) / 180;
      const R = 6371e3;
      const dLat = toRad(b.latitude - a.latitude);
      const dLng = toRad(b.longitude - a.longitude);
      const lat1 = toRad(a.latitude);
      const lat2 = toRad(b.latitude);
      const x =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(x), Math.sqrt(1 - x));
      return R * c;
    }

    function pointAtDistance(point, distanceMeters, bearingDegrees = 90) {
      if (!point) return null;
      const R = 6371e3;
      const lat1 = (point.latitude * Math.PI) / 180;
      const lng1 = (point.longitude * Math.PI) / 180;
      const brng = (bearingDegrees * Math.PI) / 180;
      const angDist = distanceMeters / R;

      const lat2 = Math.asin(
        Math.sin(lat1) * Math.cos(angDist) +
        Math.cos(lat1) * Math.sin(angDist) * Math.cos(brng)
      );
      const lng2 = lng1 + Math.atan2(
        Math.sin(brng) * Math.sin(angDist) * Math.cos(lat1),
        Math.cos(angDist) - Math.sin(lat1) * Math.sin(lat2)
      );

      return {
        latitude: (lat2 * 180) / Math.PI,
        longitude: (lng2 * 180) / Math.PI
      };
    }

    function getPinPointForWalk(walk) {
      const points = Array.isArray(walk?.points) ? walk.points : [];
      if (!points.length) return null;
      if (walk.walkType === 'area') {
        return toLatLngPoint(points[points.length - 1] || points[0]);
      }
      return toLatLngPoint(points[points.length - 1] || points[0]);
    }

    function buildRadiusClusters(walks, radiusMeters = 500) {
      const refs = walks
        .map((walk) => ({ sessionId: walk.sessionId, point: getPinPointForWalk(walk) }))
        .filter((item) => !!item.point);

      // Initial pass: assign each walk to the nearest cluster within radius
      const clusters = [];
      refs.forEach((ref) => {
        let matched = null;
        for (const cluster of clusters) {
          if (distanceMetersBetweenPoints(cluster.center, ref.point) <= radiusMeters) {
            matched = cluster;
            break;
          }
        }

        if (!matched) {
          clusters.push({
            center: { latitude: ref.point.latitude, longitude: ref.point.longitude },
            members: [ref]
          });
          return;
        }

        matched.members.push(ref);
        const total = matched.members.length;
        const sum = matched.members.reduce(
          (acc, member) => ({
            latitude: acc.latitude + member.point.latitude,
            longitude: acc.longitude + member.point.longitude
          }),
          { latitude: 0, longitude: 0 }
        );
        matched.center = {
          latitude: sum.latitude / total,
          longitude: sum.longitude / total
        };
      });

      // Merge pass: keep merging any two clusters whose circles overlap
      // (centers within 2Ã— radius) until no more merges happen
      let mergeHappened = true;
      while (mergeHappened) {
        mergeHappened = false;
        for (let i = 0; i < clusters.length; i++) {
          for (let j = i + 1; j < clusters.length; j++) {
            const dist = distanceMetersBetweenPoints(clusters[i].center, clusters[j].center);
            if (dist <= radiusMeters * 2) {
              // Merge j into i
              clusters[i].members = clusters[i].members.concat(clusters[j].members);
              const total = clusters[i].members.length;
              const sum = clusters[i].members.reduce(
                (acc, m) => ({
                  latitude: acc.latitude + m.point.latitude,
                  longitude: acc.longitude + m.point.longitude
                }),
                { latitude: 0, longitude: 0 }
              );
              clusters[i].center = {
                latitude: sum.latitude / total,
                longitude: sum.longitude / total
              };
              clusters.splice(j, 1);
              mergeHappened = true;
              break;
            }
          }
          if (mergeHappened) break;
        }
      }

      return clusters;
    }

    function toHistoryLabel(walk) {
      const start = typeof walk?.startLocationName === 'string' ? walk.startLocationName.trim() : '';
      const end = typeof walk?.endLocationName === 'string' ? walk.endLocationName.trim() : '';
      if (start && end) return start === end ? start : `${start} -> ${end}`;
      return end || start || walk?.prayerFocus || 'Prayer walk';
    }

    function highlightDayChips() {
      document.querySelectorAll('[data-days]').forEach((el) => {
        const value = Number(el.getAttribute('data-days'));
        el.classList.toggle('active', value === state.days);
      });
    }

    function parseDateTimeLocalValue(value) {
      if (!value) return null;
      const ts = new Date(value).getTime();
      return Number.isFinite(ts) ? ts : null;
    }

    function deriveFetchDaysFromFilters() {
      const startTs = parseDateTimeLocalValue(state.filterStartAt);
      if (!startTs) return state.days;
      const diff = Date.now() - startTs;
      const daysFromStart = Math.max(1, Math.ceil(diff / (24 * 60 * 60 * 1000)));
      return Math.max(state.days, daysFromStart);
    }

    function setBranchFilterOptions(rows) {
      const branches = Array.from(
        new Set(
          rows
            .map((row) => String(row.branch || '').trim())
            .filter(Boolean)
        )
      ).sort((a, b) => a.localeCompare(b));

      const selected = state.filterBranch;
      const options = [
        '<option value="">Any branch</option>',
        ...branches.map((name) => `<option value="${name}">${name}</option>`)
      ];
      if (selected && !branches.includes(selected)) {
        options.push(`<option value="${selected}">${selected}</option>`);
      }
      branchFilter.innerHTML = options.join('');

      if (selected) {
        branchFilter.value = selected;
      } else {
        branchFilter.value = '';
        state.filterBranch = '';
      }
    }

    function applyFiltersToRows(rows) {
      return rows;
    }

    function updateStats() {
      const walks = state.walks;
      const km = walks.reduce((sum, walk) => sum + Number(walk.distanceMeters || 0), 0) / 1000;

      document.getElementById('statWalks').textContent = String(walks.length);
      document.getElementById('statDistance').textContent = `${km.toFixed(2)} km`;
    }

    function focusLayerOnMap(layer, preferZoomIn = true) {
      if (!layer) return;
      const targetZoom = 16;
      const focusTo = (latLng) => {
        if (!latLng) return;
        if (preferZoomIn && map.getZoom() < targetZoom) {
          map.setView(latLng, targetZoom, { animate: true });
          return;
        }
        map.panTo(latLng, { animate: true });
      };

      if (layer.getBounds) {
        const bounds = layer.getBounds();
        if (!bounds || !bounds.isValid()) return;
        focusTo(bounds.getCenter());
        return;
      }

      if (layer.getLatLng) {
        focusTo(layer.getLatLng());
      }
    }

    function renderMap() {
      layerGroup.clearLayers();
      state.layers.clear();

      const bounds = [];
      const walksToRender = state.walks;
      const radiusMeters = 500;
      const radiusClusters = buildRadiusClusters(walksToRender, radiusMeters);

      walksToRender.forEach((walk) => {
        const points = (walk.points || []).map((p) => [Number(p.latitude), Number(p.longitude)]);
        if (!points.length) return;
        const isSelected = state.selected?.sessionId === walk.sessionId;

        const opacity = Math.max(0.2, Math.min(1, Number(walk.opacity || 0.5)));
        const baseColor = walk.walkType === 'area'
          ? `rgba(46,129,216,${opacity})`
          : `rgba(223,63,63,${opacity})`;
        const color = isSelected ? '#1f66ff' : baseColor;

        if (walk.geometryType === 'path' && points.length > 1) {
          const poly = L.polyline(points, {
            color,
            weight: isSelected ? 8 : 6,
            opacity: isSelected ? 1 : undefined,
            lineCap: 'round',
            lineJoin: 'round'
          }).addTo(layerGroup);
          poly.on('click', () => {
            openDetails(walk);
            focusLayerOnMap(poly);
          });
          state.layers.set(walk.sessionId, poly);
          points.forEach((p) => bounds.push(p));

          const endPoint = points[points.length - 1];
          if (isSelected) {
            L.circleMarker(endPoint, {
              radius: 14,
              color: '#f08c00',
              fillColor: '#ffd43b',
              fillOpacity: 0.22,
              weight: 3
            }).addTo(layerGroup);
          }
          const endPin = L.marker(endPoint, { title: toHistoryLabel(walk) }).addTo(layerGroup);
          endPin.on('click', () => {
            openDetails(walk);
            focusLayerOnMap(poly);
          });
          bounds.push(endPoint);
        } else {
          if (isSelected) {
            L.circleMarker(points[0], {
              radius: 14,
              color: '#f08c00',
              fillColor: '#ffd43b',
              fillOpacity: 0.22,
              weight: 3
            }).addTo(layerGroup);
          }
          const marker = L.marker(points[0], { title: toHistoryLabel(walk) }).addTo(layerGroup);
          marker.on('click', () => {
            openDetails(walk);
            focusLayerOnMap(marker);
          });
          state.layers.set(walk.sessionId, marker);
          bounds.push(points[0]);
        }

        if (walk.walkType === 'area') {
          const pinPoint = points[points.length - 1] || points[0];
          if (pinPoint) {
            if (isSelected) {
              L.circleMarker(pinPoint, {
                radius: 14,
                color: '#f08c00',
                fillColor: '#ffd43b',
                fillOpacity: 0.22,
                weight: 3
              }).addTo(layerGroup);
            }
            const areaPin = L.marker(pinPoint, { title: walk.prayerFocus || 'Area walk' }).addTo(layerGroup);
            areaPin.bindTooltip(`Area: ${walk.prayerFocus || 'Walked area'}`, { direction: 'top', offset: [0, -8] });
            areaPin.on('click', () => {
              openDetails(walk);
              focusLayerOnMap(areaPin);
            });
            bounds.push(pinPoint);
          }
        }
      });

      radiusClusters.forEach((cluster) => {
        // Count distinct walks (deduplicate by sessionId)
        const uniqueSessionIds = new Set(cluster.members.map((m) => m.sessionId));
        const count = uniqueSessionIds.size;
        if (count < 2) return; // only show badge when 2+ walks in cluster
        const center = cluster.center;

        L.circle([center.latitude, center.longitude], {
          radius: radiusMeters,
          color: '#1f66ff',
          weight: 1.5,
          opacity: 0.35,
          fillOpacity: 0.05,
          interactive: false
        }).addTo(layerGroup);

        L.marker([center.latitude, center.longitude], {
          icon: L.divIcon({
            className: '',
            html: `<div style="position:relative; left: 10px; bottom: 35px;"><span class="pin-count-badge">${count}</span></div>`,
            iconSize: [0, 0],
            iconAnchor: [0, 0]
          }),
          interactive: false,
          keyboard: false
        }).addTo(layerGroup);
      });

      if (!state.selected && state.suppressAutoFitOnce) {
        const point = state.closeFocusPoint;
        if (point && Number.isFinite(point.latitude) && Number.isFinite(point.longitude)) {
          const nextZoom = Math.max(12, Math.min(15, map.getZoom() - 1));
          map.setView([point.latitude, point.longitude], nextZoom, { animate: true });
        }
        state.suppressAutoFitOnce = false;
        state.closeFocusPoint = null;
        return;
      }

      // Only auto-frame once on initial load; keep camera stable during idle refreshes.
      if (!state.selected && !state.hasAutoFitted && bounds.length > 1) {
        map.fitBounds(bounds, { padding: [28, 28], maxZoom: 16 });
        state.hasAutoFitted = true;
      }
    }

    function renderHistory() {
      historyList.innerHTML = '';
      const sourceWalks = state.selected ? [state.selected] : state.walks;
      const totalPages = state.selected ? 1 : Math.max(1, Math.ceil(sourceWalks.length / state.pageSize));
      state.page = Math.max(1, Math.min(state.page, totalPages));
      const startIdx = state.selected ? 0 : (state.page - 1) * state.pageSize;
      const endIdx = state.selected ? sourceWalks.length : startIdx + state.pageSize;
      const walksToRender = sourceWalks.slice(startIdx, endIdx);
      emptyState.style.display = sourceWalks.length ? 'none' : 'block';

      walksToRender.forEach((walk) => {
        const row = document.createElement('article');
        row.className = 'walk';
        row.onclick = () => {
          openDetails(walk);
          try {
            const layer = state.layers.get(walk.sessionId);
            focusLayerOnMap(layer);
          } catch (error) {
            console.error('Failed to focus map layer:', error);
          }
        };

        row.innerHTML = `
          <div class="walk-top">
            <span>${new Date(walk.startedAt).toLocaleString()}</span>
          </div>
          <div class="focus">${toHistoryLabel(walk)}</div>
          <div class="meta">
            <span>Participants: ${toCardParticipantLabel(walk)}</span>
            <span>Duration: ${toDurationLabel(walk.durationSeconds)}</span>
            <span>Distance: ${toDistanceLabel(walk.distanceMeters)}</span>
            <span>Avg speed: ${toSpeedLabel(walk.distanceMeters, walk.durationSeconds)}</span>
          </div>
        `;

        historyList.appendChild(row);
      });

      historyPager.innerHTML = '';
      if (!state.selected && totalPages > 1) {
        const prev = document.createElement('button');
        prev.className = 'pager-btn';
        prev.textContent = 'Prev';
        prev.disabled = state.page <= 1;
        prev.onclick = () => {
          state.page = Math.max(1, state.page - 1);
          renderHistory();
        };
        historyPager.appendChild(prev);

        for (let i = 1; i <= totalPages; i += 1) {
          const crumb = document.createElement('button');
          crumb.className = `pager-btn${i === state.page ? ' active' : ''}`;
          crumb.textContent = String(i);
          crumb.onclick = () => {
            state.page = i;
            renderHistory();
          };
          historyPager.appendChild(crumb);
        }

        const next = document.createElement('button');
        next.className = 'pager-btn';
        next.textContent = 'Next';
        next.disabled = state.page >= totalPages;
        next.onclick = () => {
          state.page = Math.min(totalPages, state.page + 1);
          renderHistory();
        };
        historyPager.appendChild(next);
      }
    }

    function clearReplay() {
      if (state.replayTimer) {
        window.clearInterval(state.replayTimer);
        state.replayTimer = null;
      }
      if (state.replayMarker) {
        map.removeLayer(state.replayMarker);
        state.replayMarker = null;
      }
    }

    function openDetails(walk) {
      state.selected = walk;
      renderMap();
      renderHistory();

      const sheet = document.getElementById('detailSheet');
      const actionPrimary = document.getElementById('actionPrimary');
      const walkPoints = getWalkStartEndPoints(walk);

      document.getElementById('detailTitle').textContent = toHistoryLabel(walk);
      document.getElementById('detailWho').textContent = `Participants: ${toParticipantLabel(walk)}`;
      document.getElementById('detailWhen').textContent = `When: ${new Date(walk.startedAt).toLocaleString()}`;
      document.getElementById('detailDuration').textContent = `Duration: ${toDurationLabel(walk.durationSeconds)}`;
      document.getElementById('detailDistance').textContent = `Distance: ${toDistanceLabel(walk.distanceMeters)}`;
      document.getElementById('detailSpeed').textContent = `Avg speed: ${toSpeedLabel(walk.distanceMeters, walk.durationSeconds)}`;
      document.getElementById('detailStartCoord').textContent = `Start lat/lng: ${toPointLabel(walkPoints.start)}`;
      document.getElementById('detailEndCoord').textContent = `End lat/lng: ${toPointLabel(walkPoints.end)}`;
      document.getElementById('detailBranch').textContent = `Branch: ${walk.branch || 'Unknown'}`;

      if (walk.walkType === 'path') {
        actionPrimary.style.display = '';
        actionPrimary.textContent = 'Replay';
        actionPrimary.onclick = () => {
          clearReplay();
          const points = walk.points || [];
          if (points.length < 2) return;

          let idx = 0;
          state.replayMarker = L.circleMarker([points[0].latitude, points[0].longitude], {
            radius: 6,
            color: '#0ca678',
            fillColor: '#0ca678',
            fillOpacity: 1,
            weight: 2
          }).addTo(map);

          state.replayTimer = window.setInterval(() => {
            idx += 1;
            if (idx >= points.length) {
              clearReplay();
              return;
            }
            state.replayMarker.setLatLng([points[idx].latitude, points[idx].longitude]);
          }, 250);
        };
      } else {
        actionPrimary.style.display = 'none';
        actionPrimary.onclick = null;
      }

      sheet.classList.add('show');
    }

    function closeDetails() {
      clearReplay();
      if (state.selected && Array.isArray(state.selected.points) && state.selected.points.length > 0) {
        const points = state.selected.points;
        const midIdx = Math.floor(points.length / 2);
        const focus = points[midIdx] || points[0];
        state.closeFocusPoint = {
          latitude: Number(focus.latitude),
          longitude: Number(focus.longitude)
        };
        state.suppressAutoFitOnce = true;
      }
      state.selected = null;
      renderMap();
      renderHistory();
      document.getElementById('detailSheet').classList.remove('show');
    }

    async function fetchHistory() {
      setStatus('Loading walk history...');

      const makeUrl = () => {
        const q = String(state.filterQuery || '').trim();
        const requestLimit = q.length >= 2 ? '1000' : '300';
        const params = new URLSearchParams({
          limit: requestLimit,
          days: String(deriveFetchDaysFromFilters()),
          walkType: 'all',
          includeActive: 'true'
        });
        if (q.length >= 2) {
          params.set('q', q);
          params.set('locationQuery', q);
          params.set('allTimeSearch', 'true');
        }
        const branch = String(state.filterBranch || '').trim();
        if (branch) {
          params.set('branch', branch);
        }
        const startTs = parseDateTimeLocalValue(state.filterStartAt);
        if (startTs !== null) {
          params.set('from', new Date(startTs).toISOString());
        }
        const endTs = parseDateTimeLocalValue(state.filterEndAt);
        if (endTs !== null) {
          params.set('to', new Date(endTs).toISOString());
        }
        return `/walks/history?${params.toString()}`;
      };

      const headers = {
        Authorization: `Bearer ${authToken}`
      };

      try {
        let res = await fetch(makeUrl(), { headers });
        if (res.status === 401) { handleUnauthorized(); return; }
        if (!res.ok) throw new Error(`History failed ${res.status}`);
        let payload = await res.json();
        const rows = Array.isArray(payload.routes) ? payload.routes : [];

        state.rawWalks = rows.sort((a, b) => new Date(b.startedAt).getTime() - new Date(a.startedAt).getTime());
        setBranchFilterOptions(state.rawWalks);
        state.walks = applyFiltersToRows(state.rawWalks);
        state.page = 1;
        if (state.selected) {
          const refreshedSelected = state.walks.find((walk) => walk.sessionId === state.selected.sessionId);
          if (refreshedSelected) {
            state.selected = refreshedSelected;
          } else {
            state.selected = null;
            document.getElementById('detailSheet').classList.remove('show');
            clearReplay();
          }
        }
        updateStats();
        renderMap();
        renderHistory();
        setStatus(`Showing ${state.walks.length} of ${state.rawWalks.length} walk${state.rawWalks.length === 1 ? '' : 's'}.`);
      } catch (error) {
        console.error(error);
        state.rawWalks = [];
        state.walks = [];
        setBranchFilterOptions([]);
        updateStats();
        renderMap();
        renderHistory();
        setStatus('Failed to fetch walk history.');
      }
    }

    async function superadminRequest(url, options = {}) {
      const res = await fetch(url, {
        ...options,
        headers: {
          Authorization: `Bearer ${authToken}`,
          'Content-Type': 'application/json',
          ...(options.headers || {})
        }
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        throw new Error(data.error || `Request failed (${res.status})`);
      }
      return data;
    }

    function renderAdminUsers(rows) {
      if (!adminList) return;
      adminList.innerHTML = '';
      if (!Array.isArray(rows) || rows.length === 0) {
        adminList.innerHTML = '<p class="empty">No branch admins found.</p>';
        return;
      }

      rows.forEach((admin) => {
        const card = document.createElement('article');
        card.className = 'admin-item';
        const activeLabel = admin.isActive ? 'Active' : 'Inactive';
        const inviteLabel = admin.inviteStatus ? `Invite: ${admin.inviteStatus}` : 'Invite: none';
        const lastLogin = admin.lastLogin ? new Date(admin.lastLogin).toLocaleString() : 'Never';
        const safeEmail = String(admin.email || '').replace(/"/g, '&quot;');
        const safeBranch = String(admin.branch || '').replace(/"/g, '&quot;');
        const resendInviteId = admin.inviteId || '';

        card.innerHTML = `
          <div><strong>${admin.name || admin.email}</strong> (${activeLabel})</div>
          <div class="admin-meta">${admin.email} â€¢ Branch: ${admin.branch || 'Unassigned'} â€¢ ${inviteLabel} â€¢ Last login: ${lastLogin}</div>
          <div class="admin-actions">
            <input class="mini-input" data-branch-input="${admin.id}" value="${safeBranch}" placeholder="new branch" />
            <button class="mini-btn" data-action="reassign" data-id="${admin.id}">Reassign</button>
            <button class="mini-btn" data-action="reset" data-id="${admin.id}">Send Reset</button>
            <button class="mini-btn" data-action="resend" data-id="${resendInviteId}" ${resendInviteId ? '' : 'disabled'} data-email="${safeEmail}">Resend Invite</button>
            ${admin.isActive
            ? `<button class="mini-btn warn" data-action="deactivate" data-id="${admin.id}">Deactivate</button>`
            : `<button class="mini-btn" data-action="reactivate" data-id="${admin.id}">Reactivate</button>`}
          </div>
        `;
        adminList.appendChild(card);
      });
    }

    async function fetchSuperadminUsers() {
      if (!isSuperadmin || !superadminPanel) return;
      try {
        const data = await superadminRequest('/admin/admin-users');
        renderAdminUsers(data.admins || []);
      } catch (error) {
        setSuperadminStatus(error.message || 'Failed to load admin users.');
      }
    }

    async function sendInvite() {
      const email = String(inviteEmail?.value || '').trim();
      const branch = String(inviteBranch?.value || '').trim();
      if (!email || !branch) {
        setSuperadminStatus('Email and branch are required.');
        return;
      }
      setSuperadminStatus('Sending invite...');
      try {
        await superadminRequest('/admin/admin-invites', {
          method: 'POST',
          body: JSON.stringify({ email, branch })
        });
        setSuperadminStatus('Invite sent.');
        inviteEmail.value = '';
        inviteBranch.value = '';
        fetchSuperadminUsers();
      } catch (error) {
        setSuperadminStatus(error.message || 'Failed to send invite.');
      }
    }

    async function handleAdminAction(action, id, branchValue) {
      const actionMap = {
        deactivate: { url: `/admin/admin-users/${id}/deactivate`, method: 'POST', body: null, message: 'Admin deactivated.' },
        reactivate: { url: `/admin/admin-users/${id}/reactivate`, method: 'POST', body: null, message: 'Admin reactivated.' },
        reset: { url: `/admin/admin-users/${id}/reset-password`, method: 'POST', body: null, message: 'Reset link sent.' },
        resend: { url: `/admin/admin-invites/${id}/resend`, method: 'POST', body: null, message: 'Invite resent.' },
        reassign: { url: `/admin/admin-users/${id}/reassign-branch`, method: 'POST', body: JSON.stringify({ branch: branchValue }), message: 'Branch reassigned.' }
      };
      const cfg = actionMap[action];
      if (!cfg) return;
      if (action === 'reassign' && !String(branchValue || '').trim()) {
        setSuperadminStatus('Enter a branch value before reassign.');
        return;
      }
      setSuperadminStatus('Processing...');
      try {
        await superadminRequest(cfg.url, { method: cfg.method, body: cfg.body || undefined });
        setSuperadminStatus(cfg.message);
        fetchSuperadminUsers();
        fetchHistory();
      } catch (error) {
        setSuperadminStatus(error.message || 'Action failed.');
      }
    }

    function applyFiltersAndFetch(options = {}) {
      const query = String(searchQuery.value || '').trim();
      state.filterQuery = query.length >= 2 ? query : '';
      state.filterBranch = branchFilter.value;
      state.filterStartAt = startDateTime.value;
      state.filterEndAt = endDateTime.value;

      if (state.filterStartAt && state.filterEndAt) {
        const startTs = parseDateTimeLocalValue(state.filterStartAt);
        const endTs = parseDateTimeLocalValue(state.filterEndAt);
        if (startTs !== null && endTs !== null && startTs > endTs) {
          setStatus('Start date/time must be before end date/time.');
          return;
        }
      }

      fetchHistory();
    }

    function attachEvents() {
      document.querySelectorAll('[data-days]').forEach((chip) => {
        chip.addEventListener('click', () => {
          state.days = Number(chip.getAttribute('data-days'));
          highlightDayChips();
          fetchHistory();
        });
      });

      clearFiltersBtn.addEventListener('click', () => {
        state.filterBranch = '';
        state.filterStartAt = '';
        state.filterEndAt = '';
        state.filterQuery = '';
        searchQuery.value = '';
        branchFilter.value = '';
        startDateTime.value = '';
        endDateTime.value = '';
        closeDetails();
        fetchHistory();
      });

      searchQuery.addEventListener('keydown', (event) => {
        if (event.key !== 'Enter') return;
        event.preventDefault();
        applyFiltersAndFetch();
      });

      searchQuery.addEventListener('input', () => {
        if (searchDebounceTimer) {
          window.clearTimeout(searchDebounceTimer);
        }
        searchDebounceTimer = window.setTimeout(() => {
          applyFiltersAndFetch();
        }, 250);
      });

      branchFilter.addEventListener('change', () => {
        applyFiltersAndFetch();
      });

      startDateTime.addEventListener('change', () => {
        applyFiltersAndFetch();
      });

      endDateTime.addEventListener('change', () => {
        applyFiltersAndFetch();
      });

      if (settingsLink) {
        settingsLink.setAttribute(
          'href',
          isSuperadmin ? '/admin-settings.html?scope=superadmin' : '/admin-settings.html'
        );
      }

      if (logoutBtn) {
        logoutBtn.addEventListener('click', logout);
      }

      if (isSuperadmin && superadminPanel) {
        superadminPanel.classList.add('show');
        sendInviteBtn.addEventListener('click', sendInvite);
        inviteEmail.addEventListener('keydown', (event) => {
          if (event.key !== 'Enter') return;
          event.preventDefault();
          sendInvite();
        });
        inviteBranch.addEventListener('keydown', (event) => {
          if (event.key !== 'Enter') return;
          event.preventDefault();
          sendInvite();
        });

        adminList.addEventListener('click', (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) return;
          const action = target.getAttribute('data-action');
          const id = target.getAttribute('data-id');
          if (!action || !id) return;
          let branchValue = '';
          if (action === 'reassign') {
            const input = adminList.querySelector(`input[data-branch-input="${id}"]`);
            branchValue = input instanceof HTMLInputElement ? input.value : '';
          }
          handleAdminAction(action, id, branchValue);
        });
      }

      document.getElementById('actionSecondary').addEventListener('click', closeDetails);
      window.addEventListener('beforeunload', () => {
        clearReplay();
        if (superadminRefreshTimer) {
          window.clearInterval(superadminRefreshTimer);
          superadminRefreshTimer = null;
        }
      });
    }

    function init() {
      attachEvents();
      highlightDayChips();

      if (!navigator.geolocation) {
        fetchHistory();
      } else {
        navigator.geolocation.getCurrentPosition((position) => {
          fetchHistory();
        }, () => fetchHistory(), { timeout: 5000 });
      }

      window.setInterval(fetchHistory, 30000);
      if (isSuperadmin) {
        fetchSuperadminUsers();
        superadminRefreshTimer = window.setInterval(fetchSuperadminUsers, 30000);
      }
    }

    init();
  </script>
</body>

</html>